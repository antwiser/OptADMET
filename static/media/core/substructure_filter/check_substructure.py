'''
Description: the functions
Author: Kotori Y
Date: 2020-10-24 16:08:49
LastEditors: Kotori Y
LastEditTime: 2020-11-02 21:56:20
FilePath: \admetMesh\admetMesh\substructure_filter\check_substructure.py
AuthorMail: kotori@cbdd.me
'''

from collections import namedtuple
from functools import wraps

try:
    from load_pattern import loadpkl
except Exception:
    from .load_pattern import loadpkl


class InvalidInputError(Exception):
    pass


def withEndpoint(endpoint="PAINS"):
    def check(func):
        @wraps(func)
        def wrapper(mols, endpoint):
            pattl = loadpkl(endpoint)
            for mol in mols:
                res = func(mol=mol, pattl=pattl, endpoint=endpoint)
                yield res

        return wrapper

    return check


def checkValidMol(func):
    @wraps(func)
    def wrapper(mol, **kwgrs):
        if mol is not None:
            return func(mol, **kwgrs)
        else:
            return {}

    return wrapper


def CheckPattl(mol, rejected_pattl, accepted_pattl):
    """
    *Internal Use Only*
    
    Checking mol through 'rejected' and 'accepted' part respectively
    
    :param mol: the molecule to be scanned.
    :type mol: rdkit.Chem.rdchem.Mol
    :param rejected_pattl: the 'rejected' part of SMARTS
    :type rejected_pattl: rdkit.Chem.rdchem.Mol
    :param accepted_pattl: the 'accepted' part of SMARTS
    :type accepted_pattl: rdkit.Chem.rdchem.Mol
    
    :yield: True meant matched SMARTS, else unmatched.
    :ytype: bool
    
    """
    for reject_list, accept_list in zip(rejected_pattl, accepted_pattl):
        if (not reject_list) or (not any([mol.HasSubstructMatch(patt) for patt in reject_list])):
            if accept_list:
                yield all([mol.HasSubstructMatch(patt) for patt in accept_list])
            else:
                yield True
        else:
            yield False


@withEndpoint()
@checkValidMol
def CheckWithSmarts(mol, pattl, endpoint):
    """  
    checking molecule(s) wheather or not 
    has(have) some (toxic) substructure(s) through comparing the 
    SMILES of molecule(s) and the SMARTS of (toxic) substructure(s) 
    which obtained from Ochem Database(https://ochem.eu/alerts/home.do).
    
    :param mol: the molecule to be scanned.
    :type mol: rdkit.Chem.rdchem.Mol
    :param pattl: generated by _Loadpkl, containing 'rejected' and 'accepted' part.
    :type pattl: list
    :param endpoint: the endpoint name of pattl that de used to scan mol.
    :type endpoint: str
    :param detail: Control returning specific infomation or not, defaults to False
    :type detail: bool, optional
    
    :return: Result after scanning. If detail has been set to False, only return 'Disposed' and 'Endpoint', otherwise 'MatchedAtoms' and 'MatchedNames' are also provided.
    :rtype: namedtuple
    
    """
    reject_pattl = map(lambda x: x[-2], pattl)
    accept_pattl = map(lambda x: x[-1], pattl)

    reject_pattl = tuple(reject_pattl)
    accept_pattl = tuple(accept_pattl)

    matched_names = []
    matched_atoms = []

    names = map(lambda x: x[0], pattl)

    temp = CheckPattl(mol, reject_pattl, accept_pattl)
    temp = tuple(temp)
    if any(temp):
        disposed = 'Rejected'
        matched_patts = (pattl for pattl, bo in zip(accept_pattl, temp) if bo)
        for patts in matched_patts:
            if patts:
                matched_sub = [mol.GetSubstructMatch(patt) for patt in patts]
            else:
                # matched_sub = [(tuple([atom.GetIdx() for atom in mol.GetAtoms()]),)]
                matched_sub = [tuple([atom.GetIdx() for atom in mol.GetAtoms()])]
            matched_atoms.extend(matched_sub)
        matched_names = list((name for name, bo in zip(names, temp) if bo))

    else:
        disposed = 'Accepted'
        matched_atoms = ['-']
        matched_names = ['-']

    #        res = namedtuple('CheckRes',['Disposed','MatchedAtoms','MatchedNames','Endpoint'])
    items = ['Disposed', 'MatchedAtoms', 'MatchedNames', 'Endpoint']
    del reject_pattl, accept_pattl
    #        return res(Disposed=disposed,MatchedAtoms=matched_atoms,MatchedNames=matched_names,Endpoint=endpoint)
    dic = dict(zip(items, [disposed, matched_atoms, matched_names, endpoint]))
    return dic


if '__main__' == __name__:
    from rdkit import Chem

    smi = 'O=c1cc(-c2ccc(O)c(O)c2)oc2cc(O)cc(O)c12'
    mol = Chem.MolFromSmiles(smi)

    res = CheckWithSmarts(mols=[mol] * 10, endpoint="Acute_Aquatic_Toxicity")
    print(list(res))
